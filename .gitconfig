## In ~/.gitconfig:
# [include]
#   path = ~/IdeaProjects/shellbase/.gitconfig
#
# [user]
#   name = <name>
#   email = <email>

[pretty]
    log1        = %C(yellow)%h%C(reset) %C(blue)%ad%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset) %s
    log1reldate = %C(yellow)%h%C(reset) %C(blue)%ad (%cr)%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset) %s
    logbody       = %C(yellow)%h%C(reset) %C(blue)%ad (%cr)%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset) %s%C(reset)%n%b
    stash  = %C(yellow)%gd%Creset %C(cyan)(%cr)%Creset %s

[alias]
  # ============================================================================
  # INTROSPECTION
  # ============================================================================

  # Show all aliases (optionally search with: git alias <pattern>)
  alias = !git config --list | grep ^alias\\. | cut -c 7- | grep -Ei --color \"$1\" "#"

  # ============================================================================
  # LOGGING
  # ============================================================================

  # Log one-line with graph and decorations
  l = log --oneline --graph --decorate --color

  # Log one-line with date, author and message
  ll = log --graph --pretty=log1 --date=short

  # All branches
  la = "!f() { git ll --all \"$@\"; }; f"

  # Log commits to a file
  llf = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf 'llf: Log commits to a file.\n-p: show patches.\nUsage: git llf <file> [-p]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll \"$@\" --follow -- \"$GIT_PREFIX$t\"; \
  }; f"

  # Search commits by message
  lf = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nlf: Search commits by MESSAGE.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\nUsage: git lf <search-term> [-ip] [--all]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll --grep=\"$t\" \"$@\"; \
  }; f"

  # Ex: Search in specific file
  # git lc "getUserById" -- src/users.js
  lc = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nlc: Search commits by CODE CHANGES in diff.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\n-- file: Restrict to a file.\nUsage: git lc <search-term> [-ip] [--all] [-- file]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll -S \"$t\" \"$@\"; \
  }; f"

  # Search commits by RegEx changes
  lcr = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nlcr: Search commits by RegEx CODE CHANGES in diff.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\n-- file: Restrict to a file.\nUsage: git lcr <RegEx> [-ip] [--all] [-- file]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll -G \"$t\" \"$@\"; \
  }; f"

  # Commits by specific author
  lau = "!f() { t=\"${1:?(Search commits by AUTHOR) Missing search term}\"; shift; git ll --author=\"$t\" \"$@\"; }; f"

  # Commits in date range
  ld = "!f() { git ll --since=\"$1\" --until=\"${2:-now}\"; }; f"

  # File history with patches (-p)
  lp = "!f() { git ll -p \"$@\"; }; f"

  # ============================================================================
  # FILE INSPECTION
  # ============================================================================

  # Complete file history with diffs (follows renames)
  fl = log --follow -p --

  # Compact file history (follows renames)
  fh = log --follow --oneline --

  # Who changed what line (usage: git blame <file>)
  fblame = blame -w -C -C -C # w: Ignore whitespace changes; CCC: Detect code moved/copied within/across files (3 levels deep)

  # Short blame with just author and line (usage: git bls <file>)
  fb = blame -w -C -C -C --line-porcelain

  # List all contributors to a file (usage: git contributors <file>)
  fcon = "!f() { git log --follow --pretty=format:'%an <%ae>' -- \"$1\" | sort -u; }; f"

  # File change statistics (usage: git file-stats <file>)
  fs = log --follow --stat --

  # Count commits per author for a file (usage: git file-authors <file>)
  fa = "!f() { git log --follow --format='%an' -- \"$1\" | sort | uniq -c | sort -rn; }; f"

  # Show when file was added (usage: git file-born <file>)
  fborn = log --follow --diff-filter=A --find-renames=40% --

  # ============================================================================
  # STAGING AREA (INDEX)
  # ============================================================================

  # Remove ALL files from staging area (reset index)
  irma = reset HEAD

  # Remove specific files from staging (new syntax)
  irm = restore --staged

  # Untrack files but keep them locally (usage: git iforget <file>)
  iforget = rm --cached

  # ============================================================================
  #  STATUS & COMMITS
  # ============================================================================

  # Enhanced status: shows latest commit hash + message, then status
  statusbase = "!f() { \
    git rev-parse --git-dir > /dev/null 2>&1 || { echo 'Not a git repository' >&2; return 1; }; \
    git status -sb \"$@\"; \
  }; f"

  # No untracked files shown
  s = !git statusbase -uno \"$@\"
  # Untracked files are also shown
  sa = !git statusbase --long \"$@\"

  # Show status with patch of staged changes
  ss = "!f() { \
    git s \"$@\"; \
    printf '─────────────────── Staged changes:\n'; \
    git diff --cached; \
    git diff --cached --stat; \
  }; f"

  # Show specific commit (defaults to last) with list of changed files
  sh = log -1 --stat --pretty=logbody --date=human-local
  shp = show --pretty=logbody --date=human-local
  # Show files changed in a commit (usage: git shc <commit-hash>)
  shc  = diff-tree --no-commit-id --name-only -r
  shf = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nshf: Show file at a commit (with patch).\nUsage: git shf <file>' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git shp \"$@\" -- \"$GIT_PREFIX$t\"; \
  }; f"


  # Undo commits safely: keeps changes staged (usage: git back [n|COMMIT])
  # git back        # Undo last commit, keep changes staged
  # git back 5      # Undo last 5 commits
  # git back HEAD^^ # Undo 2 commits (alternative syntax)
  # git back a1b2c3 # Reset to specific commit
  back = "!f() { case \"${1:-}\" in \
      '-h'|'--help') printf '\nback: Branch goes back N commits (defaults to 1) or to a specific commit (changes are staged).\nUsage: git back [N|COMMIT]' >&2; return 1;; \
      '') target='HEAD~1' ;; \
      [1-9]|[1-9][0-9]) target=\"HEAD~$1\" ;; \
      *) target=\"$1\" ;; \
    esac; \
    git reset --soft \"$target\"; \
  }; f"

  # Undo commits completely: removes changes, protects local work (usage: git forget [n])
  forget = "!f() { case \"${1:-}\" in \
      '-h'|'--help') printf '\nforget: Branch goes back N commits (defaults to 1) or to a specific commit (changes are LOST, local changes preserved).\nUsage: git forget [N|COMMIT]' >&2; return 1;; \
      '') target='HEAD~1' ;; \
      [1-9]|[1-9][0-9]) target=\"HEAD~$1\" ;; \
      *) target=\"$1\" ;; \
    esac; \
    git reset --keep \"$target\"; \
  }; f"

  # Add all and commit with message (usage: git ac "message")
  ac = !git add -A && git commit -m

  # Commit tracked files
  ci = commit -a

  # Commit staged files
  cis = commit

  # Amend last commit with all tracked changes
  ca = commit -a --amend

  # Amend last commit with staged changes only
  cas = commit --amend

  # Outgoing changes: what will be pushed to upstream
  o = !git cherry -v @{upstream} && git status -sb && git diff --stat @{u}..HEAD

  # ============================================================================
  # STASH
  # ============================================================================

  # Quick stash: tracked files only, auto-generated message
  ssave = stash push

  # Save with message and include untracked files (usage: git ssave "message")
  ssavea = "!f() { git stash push -u -m \"${1:?Usage: ssavea '<message>'}\"; }; f"

  # Stash everything including ignored files
  ssavefull = stash push -a

  # List stashes with beautiful formatting
  sls = stash list --pretty=stash

  # Preview stash contents with full diff (usage: git speek [stash@{n}])
  speek = "!f() { git stash show -p ${1:-stash@{0}}; }; f"

  # Summary of stash changes (usage: git sshow [stash@{n}])
  sshow = "!f() { git stash show ${1:-stash@{0}}; }; f"

  # Apply stash and keep it in list (usage: git sapply [stash@{n}])
  sapply = "!f() { git stash apply ${1:-stash@{0}}; }; f"

  # Apply stash and remove from list (usage: git spop [stash@{n}])
  spopf = "!f() { git stash pop ${1:-stash@{0}}; }; f"

  # Interactive pop: preview before applying
  spop = "!bash -c 'git stash show -p && read -p \"Apply this stash? (y/n) \" -n 1 -r && echo && [[ $REPLY =~ ^[Yy]$ ]] && git stash pop'"

  # Drop specific stash (usage: git sdrop [stash@{n}])
  sdrop = "!f() { git stash drop ${1:-stash@{0}}; }; f"

  # Create branch from stash (usage: git sbranch <branch-name> [stash@{n}])
  sbranch = "!f() { git stash branch \"$1\" ${2:-stash@{0}}; }; f"

  # Clear all stashes (use with caution!)
  sclear = stash clear

  # WIP workflow: commit everything as work-in-progress
  wip = "!git add -A && git commit -m 'WIP'"

  # Undo WIP: reset soft to remove WIP commit
  unwip = "!git log -1 --format='%s' | grep -q '^WIP$' && git reset --soft HEAD~1 || echo 'No WIP commit found'"

  # ============================================================================
  # BRANCHING
  # ============================================================================

  # List local branches
  b = branch

  # List all branches (local + remote)
  bls = branch -a

  # Create and switch to new branch
  bc = switch -c

  # Delete local branch (safe: only if merged)
  brm = branch -d

  # Rename current branch
  bmv = branch -m

  # Create a new branch from a specific existing branch:
  #! br <new> <existing>
  #! switch <new>

  # Push new branch to origin and set upstream tracking
  # Usage: git pn <branch-name>
  pn = "!git push -u origin ${1:?Missing new branch name to push}"

  # ============================================================================
  # UTILITIES
  # ============================================================================

  # Show object type (usage: git type <object>)
  type = cat-file -t

  # Show object contents (usage: git dump <object>)
  dump = cat-file -p

[pull]
	rebase = true
